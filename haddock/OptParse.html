<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>OptParse</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_OptParse.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption" class="empty">&nbsp;</p></div><div id="content"><div id="module-header"><p class="caption">OptParse</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>A full-featured command line arguments parser. Features:
</p><ul><li> Parses both short options (<code>-i</code>) and long options (<code>--ignore</code>)
</li><li> Allows short options to be combined with other short options (<code>ls
 -lh</code> rather than <code>ls -l -h</code>) and with arguments (<code>foocmd -oarg</code>
 rather than <code>foocmd -o arg</code> and even <code>foocmd -ioarg</code> assuming that
 <code>-i</code> is an option that takes no arguments)
</li><li> Allows long option to be combined with its argument with an equal
 sign (GNU style, like <code>head --lines=20</code>). However this is optional;
 having the long option and the argument in separate words is also
 permitted (like <code>head --lines 20</code>).
</li><li> Parses &quot;commands&quot;. Examples include <code>git clone</code> or <code>cvs up</code>,
 where <code>clone</code> and <code>up</code> are the commands, respectively. Each command
 might take different options and handle positional arguments
 differently.
</li><li> Both commands and options can be abbreviated to the shortest
 unambiguous abbreviation. For example, instead of <code>--ignore-case</code>
 you could use <code>--igno</code> or even <code>--i</code> if either of those is
 unambiguous.
</li><li> Options, option arguments, commands, and positional arguments are
 all parsed using user-provided functions. For example, you can use
 this to change option arguments to different datatypes (an Int,
 say) or to make sure there is a particular number of positional
 arguments. You could make sure some options only appear on the
 command line once, or you can make implement an option that toggles
 an option on and off.
</li><li> Full error reporting using Either and a user-defined error
 object. Parsing stops when an error is found, and that error is
 reported. The user can define her own errors, which can be used if
 an error is encountered when parsing options, option arguments,
 commands, or positional arguments.
</li><li> Positional arguments and options can be freely interspersed.
</li><li> Recognizes <code>--</code> by itself and then stops parsing options. All
 subsequent words are then treated as positional arguments, even if
 they begin with dashes.
</li><li> Options can take zero, one, or two arguments.
</li></ul><p>Non-features / disadvantages:
</p><ul><li> Complicated.
</li><li> Some parsers, like System.Console.GetOpt, automatically generate
 help messages; this does not.
</li><li> Options must take a set number of arguments. Unlike
 System.Console.GetOpt, you cannot specify that an option takes an
 optional argument.
</li><li> Short options (those specified with a single dash) must be only
 one character long. So you will not be able to use this to write a
 clone of the Unix <code>find(1)</code> command.
</li><li> Although short options can be combined (e.g. <code>-isn</code> assuming <code>-i</code>
 and <code>-s</code> take no option arguments and that <code>-n</code> is an option) the
 first option must be preceded with a dash. That is, this does not
 support the style of options you find in BSD-like <code>ps(1)</code> commands,
 for example.
</li><li> Positional arguments and options may always be freely
 interspersed; this cannot be turned off.
</li></ul></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">class</span>  <a href="#t:ParseErr">ParseErr</a> a  <span class="keyword">where</span><ul class="subs"><li><a href="#v:store">store</a> :: String -&gt; a</li><li><a href="#v:badLongOpt">badLongOpt</a> :: String -&gt; a</li><li><a href="#v:ambiguousLongOpt">ambiguousLongOpt</a> :: String -&gt; [String] -&gt; a</li><li><a href="#v:badShortOpt">badShortOpt</a> :: Char -&gt; a</li><li><a href="#v:badEqualsOpt">badEqualsOpt</a> :: String -&gt; String -&gt; a</li><li><a href="#v:insufficientArgs">insufficientArgs</a> :: Either String Char -&gt; Int -&gt; [String] -&gt; a</li><li><a href="#v:longOptWithoutName">longOptWithoutName</a> :: String -&gt; a</li><li><a href="#v:noMatchingCmd">noMatchingCmd</a> :: String -&gt; a</li><li><a href="#v:ambiguousCmd">ambiguousCmd</a> :: String -&gt; [String] -&gt; a</li><li><a href="#v:noCmd">noCmd</a> :: a</li><li><a href="#v:posArgsNotAllowed">posArgsNotAllowed</a> :: String -&gt; a</li></ul></li><li class="src short"><span class="keyword">data</span>  <a href="#t:PosDesc">PosDesc</a> opts posargs err<ul class="subs"><li>= <a href="#v:NoPosArgs">NoPosArgs</a> posargs  </li><li>| <a href="#v:PosArgs">PosArgs</a> ([(opts, String)] -&gt; Either err posargs)  </li></ul></li><li class="src short"><span class="keyword">data</span>  <a href="#t:ArgDesc">ArgDesc</a> opts err<ul class="subs"><li>= <a href="#v:Flag">Flag</a> (opts -&gt; Either err opts)  </li><li>| <a href="#v:Single">Single</a> (opts -&gt; String -&gt; Either err opts)  </li><li>| <a href="#v:Double">Double</a> (opts -&gt; String -&gt; String -&gt; Either err opts)  </li></ul></li><li class="src short"><span class="keyword">data</span>  <a href="#t:OptDesc">OptDesc</a> opts err = <a href="#v:OptDesc">OptDesc</a> {<ul class="subs"><li><a href="#v:optShort">optShort</a> :: [Char]</li><li><a href="#v:optLong">optLong</a> :: [String]</li><li><a href="#v:optArgDesc">optArgDesc</a> :: <a href="OptParse.html#t:ArgDesc">ArgDesc</a> opts err</li></ul>}</li><li class="src short"><span class="keyword">data</span>  <a href="#t:CmdDesc">CmdDesc</a> cmd opts posargs err = <a href="#v:CmdDesc">CmdDesc</a> {<ul class="subs"><li><a href="#v:cmdName">cmdName</a> :: String</li><li><a href="#v:cmdF">cmdF</a> :: String -&gt; cmd</li><li><a href="#v:cmdOpts">cmdOpts</a> :: [<a href="OptParse.html#t:OptDesc">OptDesc</a> opts err]</li><li><a href="#v:cmdPos">cmdPos</a> :: <a href="OptParse.html#t:PosDesc">PosDesc</a> opts posargs err</li></ul>}</li><li class="src short"><a href="#v:parseGlobalsCmds">parseGlobalsCmds</a> :: (<a href="OptParse.html#t:ParseErr">ParseErr</a> err, Error err) =&gt; [<a href="OptParse.html#t:OptDesc">OptDesc</a> opts err] -&gt; [<a href="OptParse.html#t:CmdDesc">CmdDesc</a> cmd opts posargs err] -&gt; opts -&gt; [String] -&gt; Either err (cmd, opts, posargs)</li><li class="src short"><a href="#v:parseCmds">parseCmds</a> :: (<a href="OptParse.html#t:ParseErr">ParseErr</a> err, Error err) =&gt; [<a href="OptParse.html#t:CmdDesc">CmdDesc</a> cmd opts posargs err] -&gt; opts -&gt; [String] -&gt; Either err (cmd, opts, posargs)</li><li class="src short"><a href="#v:parseOptsArgs">parseOptsArgs</a> :: (<a href="OptParse.html#t:ParseErr">ParseErr</a> err, Error err) =&gt; [<a href="OptParse.html#t:OptDesc">OptDesc</a> opts err] -&gt; opts -&gt; ([(opts, String)] -&gt; Either err posargs) -&gt; [String] -&gt; Either err (opts, posargs)</li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">class</span>  <a name="t:ParseErr" class="def">ParseErr</a> a  <span class="keyword">where</span></p><div class="doc"><p>Instances of the ParseErr class can be used with the <code>parse</code>
 function to report errors. In addition, ParseErr can be used to
 report custom errors. For example, one of the argument processing
 functions in <code><a href="OptParse.html#t:ArgDesc">ArgDesc</a></code> can refurn a Left err to indicate that the
 user passed an incorrect value. This will terminate all further
 processing and report the error. Though options are typically
 preceded with one or two dashes, none of the arguments passed to
 the ParseErr functions are passed with leading dashes.
</p><p>Minimal complete definition: <a href="store.html">store</a>.
</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:store" class="def">store</a> :: String -&gt; a</p><div class="doc"><p>The default implementations of the class functions use the
 store function to store error messages in the class instance.
</p></div><p class="src"><a name="v:badLongOpt" class="def">badLongOpt</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: String</td><td class="doc"><p>The bad input
</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>A long option string was not recognized.
</p></div><p class="src"><a name="v:ambiguousLongOpt" class="def">ambiguousLongOpt</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: String</td><td class="doc"><p>The string the user passed
</p></td></tr><tr><td class="src">-&gt; [String]</td><td class="doc"><p>Possible matches
</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>A long option string was short but has more than one match. For
 instance the user passed the string <code>--he</code> as an option, but the
 program has options for both <code>--hello</code> and <code>--head</code>.
</p></div><p class="src"><a name="v:badShortOpt" class="def">badShortOpt</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Char</td><td class="doc"><p>Unrecognized character
</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>A short option character has no recognized matches.
</p></div><p class="src"><a name="v:badEqualsOpt" class="def">badEqualsOpt</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: String</td><td class="doc"><p>The option name
</p></td></tr><tr><td class="src">-&gt; String</td><td class="doc"><p>The option argument the user passed
</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Long options can be passed GNU style, where the option and the
 option argument appear in the same word, as in <code>--number=4</code>. This
 works when the option has one or two arguments. When an option
 argument is passed for an option that does not take any
 arguments, this function is called.
</p></div><p class="src"><a name="v:insufficientArgs" class="def">insufficientArgs</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Either String Char</td><td class="doc"><p>The option name (short or long)
</p></td></tr><tr><td class="src">-&gt; Int</td><td class="doc"><p>The number of arguments expected
</p></td></tr><tr><td class="src">-&gt; [String]</td><td class="doc"><p>Number of arguments actually received
</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>The user did not give enough option arguments.
</p></div><p class="src"><a name="v:longOptWithoutName" class="def">longOptWithoutName</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: String</td><td class="doc"><p>Text of the bad long option
</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Long option was passed, and it has an equal sign and an option
 argument, but no name (e.g. <code>--=yes</code>)
</p></div><p class="src"><a name="v:noMatchingCmd" class="def">noMatchingCmd</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: String</td><td class="doc"><p>name of unrecognized command
</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>An unrecognized command name was used.
</p></div><p class="src"><a name="v:ambiguousCmd" class="def">ambiguousCmd</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: String</td><td class="doc"><p>The string the user passed
</p></td></tr><tr><td class="src">-&gt; [String]</td><td class="doc"><p>Possible matches
</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>A command name matches more than one possible command name, for
 instance the user passed <code>fin</code> but there are commands named
 <code>find</code> and <code>finagle</code>.
</p></div><p class="src"><a name="v:noCmd" class="def">noCmd</a> :: a</p><div class="doc"><p>The user did not provide any command at all.
</p></div><p class="src"><a name="v:posArgsNotAllowed" class="def">posArgsNotAllowed</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: String</td><td class="doc"><p>Positional argument the user gave
</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>The user passed a positional argument where one is not allowed
 (e.g. for a command for which positional arguments are not
 allowed).
</p></div></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:PosDesc" class="def">PosDesc</a> opts posargs err </p><div class="doc"><p>Describes a positional argument. For example, in the command
 <code>pantry find -i name hello</code>, the positional arguments are <code>name</code>
 and <code>hello</code> (<code>-i</code> is an option, not a positional argument).
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:NoPosArgs" class="def">NoPosArgs</a> posargs</td><td class="doc"><p>Use if this command does not accept any positional
 arguments. However you still must give a function that takes no
 arguments; this function is called when and will be suppled as
 one of the elements of the tuple that <a href="parse.html">parse</a> returns. (Possible
 change: have <a href="parse.html">parse</a> return a Nothing instead in cases like
 this?)
</p></td></tr><tr><td class="src"><a name="v:PosArgs" class="def">PosArgs</a> ([(opts, String)] -&gt; Either err posargs)</td><td class="doc"><p><a href="parse.html">parse</a> parses all the positional arguments after the rest of
 the command line is processed. You supply the function that will
 be called here. This way the function can see all the command
 line arguments rather than seeing them just one at a time. Each
 element of this is a tuple, with the first part of the tuple
 being the options that were selected at the time this positional
 argument appeared, and the second being the positional argument
 itself. This way the output of the function can depend on what
 the command line options were. The function should return Left
 err if there was some problem.
</p></td></tr></table></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:ArgDesc" class="def">ArgDesc</a> opts err </p><div class="doc"><p>Describes the arguments that an option accepts. For example, the
 command <code>head</code> takes an option named <code>-n</code>, which accepts a single
 argument for the number of lines to print. Each of these
 constructors takes one argument, which is a function. The first
 argument of the function is always the command line options as they
 existed before this argument is parsed. This allows each option
 behave differently depending upon what options preceded it. For
 instance, this could be used to implement toggling behavior. Next
 the function accepts zero or more string arguments, with each
 string representing a command-line argument for the option. Finally
 each function returns an Either. Return Left err if there was some
 problem with the parse, or a Right opts with the new state of the
 command-line options.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Flag" class="def">Flag</a> (opts -&gt; Either err opts)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:Single" class="def">Single</a> (opts -&gt; String -&gt; Either err opts)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:Double" class="def">Double</a> (opts -&gt; String -&gt; String -&gt; Either err opts)</td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:OptDesc" class="def">OptDesc</a> opts err </p><div class="doc"><p>Describes a command line option. For example, in the command line
 <code>pantry find -i name Chex</code>, a command line option is <code>-i</code>.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:OptDesc" class="def">OptDesc</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:optShort" class="def">optShort</a> :: [Char]</dt><dd class="doc"><p>Short option names, without the leading dash.
</p></dd><dt class="src"><a name="v:optLong" class="def">optLong</a> :: [String]</dt><dd class="doc"><p>Long option names, without the leading dashes.
</p></dd><dt class="src"><a name="v:optArgDesc" class="def">optArgDesc</a> :: <a href="OptParse.html#t:ArgDesc">ArgDesc</a> opts err</dt><dd class="doc"><p>Whether this option takes any arguments and, if so, how many.
</p></dd></dl><div class="clear"></div></div></td></tr></table></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:CmdDesc" class="def">CmdDesc</a> cmd opts posargs err </p><div class="doc"><p>Describes a command. For instance, from the command line <code>pantry
 find -i name Chex</code>, the command is <code>find</code>.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:CmdDesc" class="def">CmdDesc</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:cmdName" class="def">cmdName</a> :: String</dt><dd class="doc"><p>The command name, such as <code>find</code>.
</p></dd><dt class="src"><a name="v:cmdF" class="def">cmdF</a> :: String -&gt; cmd</dt><dd class="doc"><p>Takes the full name of the command, returns something
 to indicate which command was called.
</p></dd><dt class="src"><a name="v:cmdOpts" class="def">cmdOpts</a> :: [<a href="OptParse.html#t:OptDesc">OptDesc</a> opts err]</dt><dd class="doc"><p>A list of all the options that the command takes.
</p></dd><dt class="src"><a name="v:cmdPos" class="def">cmdPos</a> :: <a href="OptParse.html#t:PosDesc">PosDesc</a> opts posargs err</dt><dd class="doc"><p>How to parse positional arguments for this command.
</p></dd></dl><div class="clear"></div></div></td></tr></table></div></div><div class="top"><p class="src"><a name="v:parseGlobalsCmds" class="def">parseGlobalsCmds</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="OptParse.html#t:ParseErr">ParseErr</a> err, Error err)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; [<a href="OptParse.html#t:OptDesc">OptDesc</a> opts err]</td><td class="doc"><p>Global options. For example, in the command <code>pantry -i find
 name pretzels</code>, <code>-i</code> is a global option because it appears before
 the command.
</p></td></tr><tr><td class="src">-&gt; [<a href="OptParse.html#t:CmdDesc">CmdDesc</a> cmd opts posargs err]</td><td class="doc"><p>All command descriptions
</p></td></tr><tr><td class="src">-&gt; opts</td><td class="doc"><p>Default options. When the command line is parsed, each option
 receives the options that have already been parsed. The first
 option will receive this item.
</p></td></tr><tr><td class="src">-&gt; [String]</td><td class="doc"><p>What to parse
</p></td></tr><tr><td class="src">-&gt; Either err (cmd, opts, posargs)</td><td class="doc"><p>Left if an error occurred; Right if everything succeeded. The
 tuple has the command that was seen, the final state of the
 options item, and any positional arguments.
</p></td></tr></table></div><div class="doc"><p>Parse a command line that features both global options and
 commands. This is the most heavy-duty parser.  Do not include the
 program name as the first string to parse (consistent with
 System.Environment.getArgs).
</p></div></div><div class="top"><p class="src"><a name="v:parseCmds" class="def">parseCmds</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="OptParse.html#t:ParseErr">ParseErr</a> err, Error err)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; [<a href="OptParse.html#t:CmdDesc">CmdDesc</a> cmd opts posargs err]</td><td class="doc"><p>All command descriptions
</p></td></tr><tr><td class="src">-&gt; opts</td><td class="doc"><p>Default options. When the command line is parsed, each option
 receives the options that have already been parsed. The first
 option will receive this item.
</p></td></tr><tr><td class="src">-&gt; [String]</td><td class="doc"><p>What to parse
</p></td></tr><tr><td class="src">-&gt; Either err (cmd, opts, posargs)</td><td class="doc"><p>Left if an error occurred; Right if everything succeeded. The
 tuple has the command that was seen, the final state of the
 options item, and any positional arguments.
</p></td></tr></table></div><div class="doc"><p>Parses commands, but no global options.
</p></div></div><div class="top"><p class="src"><a name="v:parseOptsArgs" class="def">parseOptsArgs</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="OptParse.html#t:ParseErr">ParseErr</a> err, Error err)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; [<a href="OptParse.html#t:OptDesc">OptDesc</a> opts err]</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; opts</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; ([(opts, String)] -&gt; Either err posargs)</td><td class="doc"><p>How to parse a list of <code>(opts, String)</code>
 pairs. This single function will be called after
 all positional arguments have been processed. The
 <code>opts</code> element of the pair specifies the options
 that were in force when the positional argument
 was encountered on the command line.
</p></td></tr><tr><td class="src">-&gt; [String]</td><td class="doc"><p>What to parse. Do not include the program name
 in the list of options to parse (this is
 consistent with what is returned by
 System.Environment.getArgs).
</p></td></tr><tr><td class="src">-&gt; Either err (opts, posargs)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Parses a command line that has options and positional
 arguments. This is the simplest parser and the one that most
 resembles many other parsers, such as System.Console.Getopt.
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.9.2</p></div></body></html>